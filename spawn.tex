\section{Spawning tasks}
\label{sec:spawn}
%
A regular function call in C/\Cpp{}is executed sequentially; a sequence of
function calls are also executed sequentially.
%
However, it is often the case that there are function calls that can be
executed at the same time without any harmful side effects.  
%
In such cases, one can make use of PFunc to execute functions in parallel with
respect to each other.  
%
For example consider \func{array\_sum} that computes the sum of the elements 
in an array:
%
\begin{lstlisting}
int array_sum (int a[], int n) { int sum = 0, i; for (i=0; i<n; ++i)  sum += a[i]; return sum; } 
\end{lstlisting}
%
Now, suppose that we are to sum up an array of 100 elements; to compute the
sum of elements in this array, we invoke \func{array_sum} as shown below:
%
\begin{lstlisting}
int main () { int a[100]; return array_sum (a, 100); }
\end{lstlisting}
%
Although this serves our purpose, we could compute the sum of the two halves 
of the array as show below as well: 
%
\begin{lstlisting}
int main () { int a[100]; return array_sum (a, 50) + array_sum (a+50, 50); }
\end{lstlisting}
%
Once we have written the problem in this form, we can see that the two
invocations of \func{array_sum} can actually be executed in parallel; it is
precisely such things that PFunc allows us to do.

\subsection{Creating work}
%
In C/\Cpp{}, a function can have any signature; that is, it can accept any
number of arguments, which can be of different types, and return any type.
%
However, because of language restrictions, PFunc can only accept one
\textit{type} of function signature.
%
In brief, PFunc accepts work in two forms: as special forms of function
pointers (C), and  function objects (\Cpp{}).  

\subsubsection{\Cpp{} function objects}
%
The \Cpp{} bindings stipulate that the function objects that want to be 
parallelized have the overloaded \lstinline{void operator()()}.
%
As function objects name concrete types, users must decide if they have more
than one \code{type} of function object that needs to be parallelized. 
%
If so, then all the function objects must derive from a common base class,
which can then be used as the type of the \code{functor} feature during
library instance generation (see Section~\ref{sec:generate}). 
%
In fact, PFunc provides such a base class, \code{pfunc::virtual\_functor}, that 
is the type of the function object when \code{pfunc::use\_default} is plugged
in for the \code{functor} feature.
%
The code given below allows parallelization of any number of function objects
as long as they inherit from \code{pfunc::virtual\_functor}: 
%
\begin{lstlisting}
/* Library instance description */
typedef pfunc::generator<cilkS, pfunc::use_default, pfunc::use_default> my_pfunc;
@\halfline@
/* First function object */
struct parallel_foo : public my_pfunc::functor { void operator()() { ... }; };
@\halfline@
/* Second function object */
struct parallel_bar : public my_pfunc::functor { void operator()() { ... }; };
\end{lstlisting}
%
In the example above, \code{pfunc::use\_default} is used as the value for the
\code{functor} feature; therefore, PFunc uses a virtual base class
(\code{pfunc::virtual\_functor}).
%
The type of this class can be accessed from the generate library instance
description using the nested type \code{::functor}. 
%
Now, invocations of \func{operator()} on both \code{parallel\_foo} and
\code{parallel\_bar} can be parallelized.

If, instead of two or more functors, there is only one functor that needs to 
be parallelized, it is more beneficial to directly plug in the type of this 
functor during library instance description generation; 
%
For example, consider the code sample given below:
%
\begin{lstlisting}
/* Forward declaration */
struct parallel_foo;
/* Library instance description */
typedef pfunc::generator<cilkS, pfunc::use_default, pfunc::use_default> my_pfunc;
@\halfline@
struct parallel_foo { void operator()() { ... }; };
\end{lstlisting}
%
In this case, \code{parallel_foo} is the only function object that can be 
parallelized by the library instance \code{my_pfunc}. 
%
As the function object is explicitly named, PFunc avoids making virtual
function calls when spawning tasks. 

\subsubsection{C-style function pointers}
PFunc accepts function pointers of the type \code{void (*)(void*)}. The
example below demonstrates how one such function looks like.

\begin{lstlisting}
void parallel_foo (void* arg) { printf ("PFunc task printing: %s\n", (char*)arg); }
\end{lstlisting}

Note that the function only accepts a single argument of type \code{void*}.
Because of the constraints of a statically typed language, PFunc cannot accept
arbitrary function objects as tasks.  However, PFunc provides two function
calls - \func{pfunc_pack} and \func{pfunc_unpack} to facilitate currying
arguments to and from parallel functions (see Section~\ref{sec:pack}).

\subsection{Spawning tasks}
Once we have initialized the library and created work (functions or function
objects), we can parallelize execution of these work packets using PFunc. 
%
In addition to the work packets, each task is comprised of three additional
details. These are:

\begin{list}{\labelitemi}{\leftmargin=0em}
\item \code{attribute:} controls the execution of the task (see
Section~\ref{sec:attribute}).  PFunc provides a suitable default value to this
parameter.
\item \code{group:} enables SPMD-style task groups (see
Section~\ref{sec:group}).  PFunc provides a suitable default value to this
parameter.
\item \code{task:} a handle to the spawned task, which can be used to query the
status of the spawned task.
\end{list}

\subsubsection{Spawning tasks in C}
\label{subsubsec:spawn_c}
Consider the code sample give below, which parallelizes the execution of 
\func{parallel\_foo}:
%
\begin{lstlisting}
void parallel_foo (void* arg) { printf ("PFunc task printing: %s\n", (char*)arg); }
@\halfline@
int main () {
  pfunc_cilk_task_t tasks[10];
  unsigned int num_queues = 4;
  const unsigned int num_threads_per_queue[] = {1,1,1,1};
  pfunc_cilk_taskmgr_t cilk_tmanager;
  int i;
@\halfline@
  /* Initialize a global instance of the library */
  pfunc_cilk_taskmgr_init (&cilk_tmanager, num_queues, num_threads_per_queue, NULL);
@\halfline@
  /* Spawn the tasks */
  for (i=0; i<10; ++i) {
    pfunc_cilk_task_init (&(tasks[i]));
    pfunc_cilk_spawn_c (cilk_tmanager, tasks[i], NULL, NULL, parallel_foo, ltoa(i));
  }
@\halfline@
  /* Wait for the tasks and clear the task handle */
  for (i=0; i<10; ++i) {
    pfunc_cilk_wait (cilk_tmanager, tasks[i]);
    pfunc_cilk_task_clear (&(tasks[i]));
  }
@\halfline@
  /* Clear the library */
  pfunc_cilk_taskmgr_clear (&cilk_tmanager);
@\halfline@
  return 0;
}
\end{lstlisting}
%
In the above example, we first initialize the Cilk-style library instance using the
function call \func{pfunc_cilk_taskmgr_init}; for this we four use task
queues, one thread per queue and allow default values for thread affinities.
%
Next, we spawn ten instances of \func{parallel_foo} using the function
\func{pfunc_cilk_spawn_c}; in this example, we choose to use the default value
,\code{NULL}, for both \code{attribute} and \code{group}. 
%
Unlike in \Cpp{}, where we use function overloading to supply default values, 
it is necessary to provide \code{NULL} for unused parameters in C.
%
Notice that the task handle has to be initialized (using
\func{pfunc_cilk_task_init}) prior to its use in \func{pfunc_cilk_spawn_c}. 
%
This is required as the C types are mere pointers to their \Cpp{} counterparts. 
%
Next, we wait for the spawned tasks to finish using
\func{pfunc_cilk_wait} before clearing the task handles. 
%
Finally, we clear the initialized library using
\func{pfunc_cilk_taskmgr_clear}. 
%
This deallocates all resources (threads and internal queues) that are in use by
PFunc. 
%
Note that we could have use the global runtime facility provided by PFunc in
this example by setting up \code{cilk_tmanager} using \func{pfunc_cilk_init}.

\subsubsection{Spawning tasks in \Cpp{}}
\label{subsubsec:spawn_cxx}
In this section, we will parallelize the execution of a function object that is
equivalent to the function parallelized in the previous section. The code is 
given below:
%
\begin{lstlisting}
/* Forward declaration */
struct parallel_foo;
/* Library instance description */
typedef pfunc::generator<cilkS, pfunc::use_default, pfunc::use_default> my_pfunc;
@\halfline@
struct parallel_foo {
  int id;
  void initialize (const int& _id) { id = _id; }
  void operator()() { std::cout << "PFunc task number:" << id << std::endl; }
};
@\halfline@
int main () {
  my_pfunc::task tasks[10];
  parallel_foo work[10];
  unsigned int num_queues = 4;
  const unsigned int num_threads_per_queue[] = {1,1,1,1};
@\halfline@
  /* Initialize an instance of the library */
  my_pfunc::taskmgr cilk_tmanager (num_queues, num_threads_per_queue);
@\halfline@
  /* Make this instance the global runtime */
  pfunc::init (cilk_taskmgr);
@\halfline@
  /* Spawn the tasks */
  for (int i=0; i<10; ++i) {
    work[i].initialize (i);
    pfunc::spawn (tasks[i], work[i]);
  }
@\halfline@
  /* Wait for the tasks and clear the task handle */
  for (int i=0; i<10; ++i) pfunc::wait (tasks[i]);
@\halfline@
  /* Clear the global runtime */
  pfunc::clear ();
@\halfline@
  return 0;
}
\end{lstlisting}
%
This example has many changes from its C counterpart. 
%
First, notice that we do not have to initialize objects such as \code{task},
\code{attribute} or \code{group} as they are initialized on construction. 
%
Second, default values for unused parameters such as \code{affinity} (for
\func{pfunc::init}), \code{attribute} and \code{group} (for
\func{pfunc::spawn}) are filled in automatically, and consequently, there is no
need to explicitly pass their values. 
%
Finally, notice that we use the global version of the functions \func{spawn}
and \func{wait} because we set up \code{cilk_tmanager} as our global runtime.

\subsubsection{Waiting on tasks}

\begin{table}
\begin{center}
\begin{tabular}{|c|c|l|}
\hline
\Cpp{} & C & Description \\
\hline
\func{pfunc::wait} & \func{pfunc\_*\_wait} & Wait till completion of the listed task.\\
\hline
\func{pfunc::wait\_all} & \func{pfunc\_*\_wait\_all} & Wait till completion of all the listed tasks.\\
\hline
\func{pfunc::wait\_any} & \func{pfunc\_*\_wait\_any} &  Wait till completion of any one of the listed tasks.\\
\hline
\func{pfunc::test} & \func{pfunc\_*\_test} & Test for completion (non-blocking) of the listed task.\\
\hline
\func{pfunc::test\_all} & \func{pfunc\_*\_test\_all} &  Test for completion of all the listed tasks.\\
\hline
\end{tabular}
\end{center}
\caption{Different types of wait in PFunc. For the C functions, \code{*} must 
be replaced by one of \code{cilk}, \code{fifo}, \code{lifo}, and \code{prio}
depending on which scheduling policy is used.}
\label{tbl:wait}
\end{table}
%
In the examples seen till now, we used \func{pfunc::wait} (or
\func{pfunc_<schedpolicy>_wait}) to wait on spawned tasks. However, there are
multiple functions which allow users to check the status of spawned tasks.
%
These are summarized in Figure~\ref{tbl:wait}. Using these new functions, the
waiting portion of the code sample in Section~\ref{subsubsec:spawn_c} can be
rewritten to be \lstinline{pfunc_cilk_wait_all (cilk_tmanager, tasks, 10)}.
%
Similarly, the waiting portion of the code sample in
Section~\ref{subsubsec:spawn_cxx} can be rewritten to be
\lstinline{pfunc::wait_all (tasks, 10)}.
