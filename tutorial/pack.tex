\section{Packing arguments in C}
\label{sec:pack}
%
For a function to be parallelized using PFunc, it must have the signature
\code{void (*)(void*)}; that is, it must accept a single \code{void*} as 
argument and return \code{void}.
%
Unfortunately, this restriction forces programmers to pack all arguments to
their parallel functions into either a single structure or buffer. 
%
Although this is relatively easy to do for functions that accept small number
of arguments, passing arguments back and forth is tedious for most functions. 
%
To help passing arguments to functions, PFunc provides two function calls:
\func{pfunc_pack} and \func{pfunc_unpack}. 
%
These two functions are similar in vein to \code{stdlib}'s \func{printf}
function in that they both take in a format specifier that allows us to pack
arguments using \code{varargs}. 
%
Given below is the rewritten Fibonacci example from Section~\ref{sec:fibonacci}
using \func{pfunc\_pack} and \func{pfunc\_unpack} instead of \code{struct
fib\_t}.
%
\begin{lstlisting}
void parallel_fib (void* arg) {
  int n;
  int* fib_n;
@\halfline@
  /* unpack the arguments */
  pfunc_unpack (arg, "int, int*", &n, &fib_n);
@\halfline@
  if (0 == n || 1 == n) *fib_n = n;
  else {
    int x, y;
    pfunc_cilk_task_t fib_task;
    char* fib_arg_1;
    char* fib_arg_2;
@\halfline@
    /* Pack the arguments to the function call */
    pfunc_pack (&fib_arg_1, "int, int*", n-1, &x);
    pfunc_pack (&fib_arg_2, "int, int*", n-2, &y);
@\halfline@
    pfunc_cilk_task_init (&fib_task);
@\halfline@
    pfunc_cilk_spawn_c_gbl (fib_task, NULL, NULL, parallel_fib, fib_arg_1);
    parallel_fib (fib_arg_2);
@\halfline@
    pfunc_cilk_wait_gbl (fib_task);
    pfunc_cilk_task_clear (&fib_task);
@\halfline@
    *fib_n = x + y;
  }
}
\end{lstlisting}
%
Here, we first use \func{pfunc\_unpack} to get the arguments to the 
current invocation of \func{parallel_fib}. 
%
Later, for non-base cases, we utilize \func{pfunc_pack} to prepare the
arguments for the recursive invocation of \func{parallel_fib}. 
%
Notice that no memory was allocated for the buffers during \func{pfunc_pack} or
that no memory was freed following the call to \func{pfunc_unpack}. 
%
This is because PFunc internally allocates/deallocates memory required for
the packing and unpacking of the function parameters. 

\subsection{Caveats}
As both \func{pfunc_pack} and \func{pfunc_unpack} utilize \code{varargs} to
parse their inputs \code{char}, \code{unsigned char}, \code{float}, and 
user-defined types (\code{struct}s) cannot be
used as parameters.
%
The valid values inside the format string of \func{pfunc_pack} and
\func{pfunc_unpack} are: \code{int}, \code{unsigned int}, \code{long int},
\code{int*}, \code{unsigned int*}, \code{long int*}, \code{int**},
\code{unsigned int**}, \code{long int**}, \code{char*}, \code{unsigned char*},
\code{char**}, \code{unsigned char**}, \code{float*}, \code{float**},
\code{double}, \code{double*}, \code{double**} and \code{void*}.
