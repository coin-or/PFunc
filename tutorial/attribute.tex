\section{Attributes}
\label{sec:attribute}
%
PFunc is built on the philosophy that not all tasks are created the same;
hence, PFunc provides the users control over the execution of each individual
task using the ``attribute'' mechanism. 
%
In PFunc, a task has many attributes, and are briefly summarized below (for a 
more detailed description, please see Section~\ref{subsubsec:attribute}):

\begin{list}{\labelitemi}{\leftmargin=1em}
\item \code{Priority:} When the scheduling policy under use utilizes task
priorities (eg., \code{prioS}), the value of this attribute is used to
prioritize tasks.
%
\item \code{Queue number:} The value of this attribute determines the task
queue on which the associated spawned task is put; valid values are
$[0,nqueues)$.
%
By default, a task is spawned on the queue of the thread that is executing the
spawning task. 
%
\item \code{Num waiters:} By default, each task's completion notification is
delivered to only one waiting task (usally the spawning task). 
%
However, users can enable the delivery of multiple task completion
notifications by setting this attribute to a value greater than 1, which is the
default value. 
%
\item \code{Grouped:} The value to this attribute determines if the spawned
task is associated with a group or not; by default, a tasks are not attached to
the group they are spawned with. 
%
To attach a task to the group, users should turn set the value of this
attribute to \code{true}.
%
\item \code{Nested:} Nested parallelism is one of the founding principles of
task parallelism; without nesting, it would be difficult to have a large number
of tasks be executed in parallel by a small number of threads. 
%
However, users can turn off nested parallelism on a task by task basis by
unsetting this attribute.
\end{list}

\subsection{\Cpp{}}
Attributes in \Cpp{} are manipulated through objects of type \code{attribute}.
The following example depicts how one can enable multiple completion
notifications using task attributes.
%
\begin{lstlisting}
/* Function object that is to be executed */
struct my_func_obj { void operator () { ... } };
@\halfline@
/* Library instance description */
typedef pfunc::generator<cilkS, pfunc::use_default, my_func_obj> my_pfunc;
@\halfline@
const unsigned int num_queues = 4; 
const unsigned int threads_per_queue[] = {1, 1, 1, 1}; 
@\halfline@
/* Initialize the library */
my_pfunc::taskmgr cilk_tmanager (num_queues, threads_per_queue);
@\halfline@
/* Set the number of waiters for this task to be 4 */
my_pfunc::attribute my_attr;
pfunc::attr_num_waiters_set (my_attr, 4);
@\halfline@
/* Create the task handle */
my_pfunc::task my_task;
@\halfline@
/* Spawn the task */
pfunc::spawn (cilk_tmanager, my_task, my_attr, my_func_obj());
@\halfline@
...
@\halfline@
/* Wait for the task to complete */
pfunc::wait (cilk_tmanager, my_task);
\end{lstlisting}
%
The first portion of the code shown in the above example reinforces the notion
of generating the library instance description and initializing a global object
of type \code{taskmgr}. 
%
In our example, we have chosen Cilk-style scheduling and initialized the
library with 4 threads with each thread having its own task queue. 
%
Next, we set up the task to deliver four task completion notifications using
\func{pfunc::attr_num_waiters_set}; that is, four other tasks can wait on the
completion of this task. 
%
The functions that can be used to manipulate task attributes are given in 
Table~\ref{tbl:attributes}.
%
\begin{table}
\tablefont
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Function & Explanation & Values\\
\hline
\func{attr_priority_set} & Set/Get task's priority & Depends on type \\
\func{attr_priority_get} & & Eg., if priority == \code{int} \\ 
                         &                     & then, MIN\_INT to MAX\_INT\\
\hline
\func{attr_queue_num_set} & Set/Get task's queue number & 0 to num\_queues-1 \\
\func{attr_queue_num_get} & & \\
\hline
\func{attr_num_waiters_set} & Set/Get the number of & 1 to num\_tasks \\
\func{attr_num_waiters_get} & completion notifications & \\
\hline
\func{attr_grouped_set} & Set/Get task's grouped attribute & \code{true, false} \\
\func{attr_grouped_get} & & \\
\hline
\func{attr_nested_set} & Set/Get task's nested attribute & \code{true, false} \\
\func{attr_nested_get} & nested & \\
\hline
\func{pfunc_<schedpolicy>_attr_init} & Initialize/Clear the attribute & \\
\func{pfunc_<schedpolicy>_attr_clear} & & \\
\hline
\end{tabular}
\end{center}
\caption{\Cpp{} functions (first 10) that are use to set and get the various
attributes associated with each task. Their C counterparts can be deduced by
adding the prefix \code{pfunc_<schedpolicy>_}. For example, the C equivalent of
the function \func{attr_priority_set} for Cilk-style scheduling is
\func{pfunc_cilk_attr_priority_set}. Note that in C, task priorities are
limited to be \code{int}s. The last two functions are strictly C and are
required to initialize an clear the attribute structure.}
\label{tbl:attribute}
\normalfont
\end{table}
%
If it suffices to have a task be executed using default values for all the 
attributes, no object of type \code{attribute} is needed to spawn such a task.
In these cases, default values are used.

\subsection{C}
The only additional step required in case of using the C interface is the 
initialization of the object of type attribute. 
%
This is required for all PFunc types when using the C interface as they are
mere pointers to \Cpp{} objects.
%
The equivalent code of the \Cpp{} example described in the previous section 
is shown below. 
%
\begin{lstlisting}
/* Function object that is to be executed */
void my_func (void* arg) { ... }
@\halfline@
const unsigned int num_queues = 4; 
const unsigned int threads_per_queue[] = {1, 1, 1, 1}; 
pfunc_cilk_taskmgr_t cilk_tmanager;
@\halfline@
/* Initialize the library */
pfunc_cilk_taskmgr_init (&cilk_tmanager, num_queues, threads_per_queue, NULL);
@\halfline@
/* Set the number of waiters for this task to be 4 */
pfunc_cilk_attr_t my_attr;
pfunc_cilk_attr_init (&my_attr);
pfunc_cilk_attr_num_waiters_set (my_attr, 4);
@\halfline@
/* Create the task handle */
pfunc_cilk_task_t my_task;
@\halfline@
/* Spawn the task */
pfunc_cilk_spawn_c (cilk_tmanager, my_task, my_attr, NULL /*group*/, my_func, NULL /*arg*/);
@\halfline@
/* Clear the attribute */
pfunc_cilk_attr_clear (&my_attr);
@\halfline@
...
@\halfline@
/* Wait for the task to complete */
pfunc_cilk_wait (cilk_tmanager, my_task);
\end{lstlisting}

Note that the attribute associated with a spawned task can be cleared (using
\code{pfunc_cilk_attr_clear}) at anytime after the spawn. 
%
Similar to the \Cpp{} interface, the C interface provides functions to set and
get all the different attributes that can be associated with a task.
