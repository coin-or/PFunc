\documentclass[9pt,twocolumn,letter]{article}

\include{pfunc-defs} 
\lstset{language=C++,style=basic}

\begin{document}

\title{PFunc: A Vehicle For Learning Shared-memory Task Parallelism}

\author{
Prabhanjan Kambadur and Anshul Gupta\\ 
IBM T J Watson Research Center\\
{\texttt \{pkambadu,anshul\}@us.ibm.com}
}

\date{}

\maketitle


\begin{abstract} 
Task parallelism is a simple, generic model of parallelism in which each 
program is broken down into indivisible tasks that need to be executed in 
order for the program to complete.
%
This model is very generic and subsumes both the data parallel and
SPMD~\cite{darema2001} models, and can be used to parallelize both regular and
irregular applications.
%
\end{abstract}

\section{Introduction}
% The importance of hands-on parallel programming instructions
Confucius, the great Chinese philosopher, is credited with saying ``I hear,
I know. I see, I remember. I do, I understand''.
%
The importance of hands-on teaching in parallel programming cann

%
Previously, hands-on parallel programming were outside the reach of many 
classrooms due to the lack of parallel programming platforms.
% 
However, thanks to the ubiquity of 
% Why teach task parallelism instead of other forms
Of the available parallel programming models, the task parallel model appears
to be the most promising in meeting these new challenges.  The task parallel
model is sufficiently high-level and generic, thereby enabling it to
parallelize regular and irregular applications on shared, distributed and
heterogeneous architectures alike.  

% Languages, language extensions, library models.
% Why is the library model practical and better for pedagogy?
Task parallel programming environments can be broadly classified into three
kinds: languages, language extensions and pragmas, and libraries.
% Languages
Many modern programming languages offer direct support for task parallelism
(eg., Chapel~\cite{Chamberlain:2007p1040}, Fortress~\cite{fortress}, and
X10~\cite{Charles:2005p1232}).
%
However, these new languages are not well suited for learning parallel
programming as they hide the machinery necessary for realizing task
parallelism.
%
Furthermore, these new languages are not yet used either in the industry or in
academia --- so, the exercise of learning parallelism through new languages 
might be in vain.
%
Finally, learning a new language takes focus away from learning parallel
programming itself and therefore might be counter-productive.
% Language extensions
Language extensions and pragmas such as Cilk~\cite{FrigoLeRa98},
OpenMP~\cite{kn:omp_30}, HP\Cpp{}~\cite{gannon:hpc}, Fx~\cite{Gross:1994} and
\Charmpp{}~\cite{Kale93charm++:a} that provide task parallelism add only a few
new ``keywords'' to existing stock programming languages, making their
adaptation (relative to new languages) easier.
%
However, for pedantic purposes, they suffer from many of the shortcomings of
new languages.
% Libraries
Libraries written in stock programming languages such as C/\Cpp{} have long 
been used in both industry and academia for parallelizing applications.
%
Well-designed task parallel libraries offer an unique advantage for pedantic
purposes in that they do not require learning a new language nor do they
encumber laborious installation procedures.
%
Furthermore, as most of the machinery is written in stock programming
languages, essential programming tools such as debuggers, performance
profilers, and memory checkers can be used to both develop parallel programs
and understand some of the ``little details'' that affect a parallel program's
behavior.

%
% Why should PFunc be the recommended vehicle for teaching undergraduate 
% course work? What are its benefits? Address these two questions.
%
% 1. Open-source with BSD-style license.
% 2. Portable to Windows, Linux, OSX, and AIX.
% 3. Well documented and stable.
% 4. Works with stock C++ compiler, no tool chain necessary.
% 5. Can be used for a followup course or for students who are more 
%    adventerous.
% 6. Many examples to choose from (DAG scheduling, Itemset mining, 
%    BLAS, select NAS parallel benchmarks, simple examples).
% 7. Actively supported.
%



However, current solutions for task
parallelism do not provide all the necessary features required for the
efficient parallelization of modern scientific computing, informatics, and
traditionally mainstream serial applications.  Execution parameters such as
task scheduling and task affinities are not exposed to the users. This
disallows user-driven customizations that are often critical to attaining good
application performance. Furthermore, lack of features such as task groups,
task priorities, and multiple task completion notifications prevents natural
expression of a wide variety of parallel algorithms including those normally
expressed in the SPMD model. Instead, users are forced to express their
algorithms in a manner that is less natural but more conducive to
parallelization by the parallel programming tool in use.


\section{PFunc}
\label{sec:pfunc}
%  - Give people a flavor of whats going on.
%    - Task parallel library
%    - Hello world -- fibonacci
%  - What is significantly different. describe only those features
%    that are different.
%    - One or two inlined calls that depict how to utilize the feature.
%  - Describe all the features for completeness.
%    - This is important to point out that we are a superset of TBB and Cilk
%      and OpenMP.

PFunc, short for Parallel Functions, is a lightweight and portable library that
provides C and \Cpp{} APIs to express task parallelism. The features offered by
PFunc are a strict superset of the features offered by current solutions for
task parallelism.  Specifically, PFunc extends the feature set of current
solutions with custom task scheduling, task priorities and task affinities.
Furthermore, PFunc offers task groups for SPMD-style programming and multiple
task completion notifications for parallel execution of DAGs.  PFunc's extended
feature set is geared towards helping knowledgeable users optimize their
application performance. In this section, we describe PFunc with an emphasis on
its new features.  Due to space constraints, all the code samples given in this
section are in \Cpp{}. All the functionality described in this section is also
available through PFunc's C interface.

PFunc's design is based on the principles of generic and generative
programming. As a result, PFunc is able to offer a wide variety of
customizations to its users without incurring any runtime penalties.  

\small
\bibliographystyle{plain}
\bibliography{refs}

\end{document}
